define sum(from,to,func) {
	if(not is_value(from) or not is_value(to)) then
		(error("sum: from,to arguments not values");bailout)
	else if(not is_function_ref(func)) then
		(error("sum: func argument not a function reference");bailout);
	r = 0;
	while (from<=to) do (r = r + *func(from); from=from+1);
	r
}
define prod(from,to,func) {
	if(not is_value(from) or not is_value(to)) then
		(error("prod: from,to arguments not values");bailout)
	else if(not is_function_ref(func)) then
		(error("prod: func argument not a function reference");bailout);
	r = 1;
	while (from<=to) do (r = r * *func(from); from=from+1);
	r
}
define nPr(n,r) {
	if(not is_value(n) or not is_value(r)) then
		(error("nPr: n,r arguments not values");bailout)
	else if(not is_integer(n) or not is_integer(r)) then
		(error("nPr: argument not an integer");bailout)
	else if(r<0 or n<0 or r>n) then
		0
	else
		(n!)/((n-r)!)
}
define nCr(n,r) {
	if(not is_value(n) or not is_value(r)) then
		(error("nCr: n,r arguments not values");bailout)
	else if(not is_integer(n) or not is_integer(r)) then
		(error("nCr: argument not an integer");bailout)
	else if(r<0 or n<0 or r>n) then
		0
	else
		(n!)/(r!*(n-r)!)
}

# return the fibbonachi number, calculated using an iterative method
define fib(x) {
	if(not is_value(x) or not is_integer(x)) then
		(error("fib: argument not an integer");bailout)
	else if(x<0) then
		(error("fib: argument less then zero");bailout)
	else if(x==0) then 0
	else if(x==1) then 1
	else (
		i=0;
		c=1;
		p=0;
		x=x-2;
		while(x>=i) do (
			c=c+p;
			p=c-p;
			i=i+1
		);
		c
	)
}

#calculate the row-echelon form of a matrix
define ref(m) {
	if(not is_matrix(m) or not is_value_only(m)) then
		(error("ref: argument not a value only matrix");bailout);
	s=min(rows(m),columns(m));
	i=1;
	d=1;
	while(d<=s and i<=columns(m)) do (

		# This just makes the anchor element non-zero if at
		# all possible
		if(m@(d,i)==0) then (
			j=d+1;
			while(j<=rows(m)) do (
				if(m@(j,i)==0) then (j=j+1;continue);
				a=m@(j,);
				m@(j,)=m@(d,);
				m@(d,)=a;
				j=j+1;
				break
			)
		);
		if(m@(d,i)==0) then (i=i+1;continue);

		# Here comes the actual zeroing of all but the anchor
		# element rows
		j=d+1;
		while(j<=rows(m)) do (
			if(m@(j,i)!=0) then (
				m@(j,)=m@(j,)-(m@(j,i)/m@(d,i))*m@(d,)
			);
			j=j+1
		);
		m@(d,) = m@(d,) * (1/m@(d,i));
		d=d+1;
		i=i+1
	);
	m
}

#calculate the reduced row-echelon form of a matrix
define rref(m) {
	if(not is_matrix(m) or not is_value_only(m)) then
		(error("rref: argument not a value only matrix");bailout);
	m = ref(m);

	i=1;
	j=1;
	while(i<=rows(m) and j<=columns(m)) do (
		while(j<=columns(m) and m@(i,j)==0) do j=j+1;
		if(j>columns(m)) then break;
		ii=1;
		while(ii<i) do (
			if(m@(ii,j)!=0) then (
				m@(ii,)=m@(ii,)-(m@(ii,j)*m@(i,))
			);
			ii=ii+1
		);
		j=j+1;
		i=i+1
	);
	m
}

#calculate a trace function
define trace(m) {
	if(not is_matrix(m) or not is_value_only(m)) then
		(error("trace: argument not a value only matrix");bailout)
	else if(rows(m)!=columns(m)) then
		(error("trace: matrix not a square");bailout);
	i=1;
	a=0;
	while(i<=rows(m)) do (a=a+m@(i,i);i=i+1);
	a
}
